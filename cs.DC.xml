<rss version="2.0"><channel><title>Chat Arxiv cs.DC</title><link>https://github.com/qhduan/cn-chat-arxiv</link><description>This is arxiv RSS feed for cs.DC</description><item><title>&#26412;&#35770;&#25991;&#20171;&#32461;&#20102;&#19968;&#31181;&#22522;&#20110;&#22810;&#39033;&#24335;&#22522;&#25968;2&#25351;&#25968;&#38598;&#21512;&#30340;&#24555;&#36895;&#20056;&#27861;&#26041;&#27861;&#65292;&#22312;&#29305;&#23450;&#20301;&#25968;&#33539;&#22260;&#20869;&#27604;&#20256;&#32479;&#26041;&#27861;&#26356;&#24555;&#12290;&#35813;&#26041;&#27861;&#25226;&#25968;&#23383;&#34920;&#31034;&#20026;&#25972;&#25968;&#32034;&#24341;&#21015;&#34920;&#65292;&#24182;&#23454;&#29616;&#20102;&#20998;&#24067;&#24335;&#35745;&#31639;&#12290;</title><link>https://arxiv.org/abs/2311.09922</link><description>&lt;p&gt;
&#36890;&#36807;&#37319;&#29992;&#25972;&#25968;&#21015;&#34920;&#20316;&#20026;&#22810;&#39033;&#24335;&#22522;&#25968;2&#25351;&#25968;&#30340;&#38598;&#21512;&#26469;&#23454;&#29616;&#24555;&#36895;&#20056;&#27861;
&lt;/p&gt;
&lt;p&gt;
Fast multiplication by two's complement addition of numbers represented as a set of polynomial radix 2 indexes, stored as an integer list for massively parallel computation
&lt;/p&gt;
&lt;p&gt;
https://arxiv.org/abs/2311.09922
&lt;/p&gt;
&lt;p&gt;
&#26412;&#35770;&#25991;&#20171;&#32461;&#20102;&#19968;&#31181;&#22522;&#20110;&#22810;&#39033;&#24335;&#22522;&#25968;2&#25351;&#25968;&#38598;&#21512;&#30340;&#24555;&#36895;&#20056;&#27861;&#26041;&#27861;&#65292;&#22312;&#29305;&#23450;&#20301;&#25968;&#33539;&#22260;&#20869;&#27604;&#20256;&#32479;&#26041;&#27861;&#26356;&#24555;&#12290;&#35813;&#26041;&#27861;&#25226;&#25968;&#23383;&#34920;&#31034;&#20026;&#25972;&#25968;&#32034;&#24341;&#21015;&#34920;&#65292;&#24182;&#23454;&#29616;&#20102;&#20998;&#24067;&#24335;&#35745;&#31639;&#12290;
&lt;/p&gt;
&lt;p&gt;

&lt;/p&gt;
&lt;p&gt;
&#25105;&#20204;&#28436;&#31034;&#20102;&#19968;&#31181;&#22522;&#20110;&#29992;&#25972;&#25968;&#21015;&#34920;&#34920;&#31034;&#30340;&#22810;&#39033;&#24335;&#22522;&#25968;2&#25351;&#25968;&#38598;&#21512;&#30340;&#20056;&#27861;&#26041;&#27861;&#12290;&#35813;&#26041;&#27861;&#37319;&#29992;python&#20195;&#30721;&#23454;&#29616;&#20102;&#19968;&#32452;&#31639;&#27861;&#12290;&#25105;&#20204;&#23637;&#31034;&#20102;&#35813;&#26041;&#27861;&#22312;&#26576;&#19968;&#20301;&#25968;&#33539;&#22260;&#20869;&#27604;&#25968;&#35770;&#21464;&#25442;(NTT)&#21644;&#21345;&#25289;&#33576;&#24052;(Karatsuba)&#20056;&#27861;&#26356;&#24555;&#12290;&#25105;&#20204;&#36824;&#23454;&#29616;&#20102;&#29992;python&#20195;&#30721;&#36827;&#34892;&#27604;&#36739;&#65292;&#19982;&#22810;&#39033;&#24335;&#22522;&#25968;2&#25972;&#25968;&#26041;&#27861;&#36827;&#34892;&#27604;&#36739;&#12290;&#25105;&#20204;&#23637;&#31034;&#20102;&#20219;&#20309;&#25972;&#25968;&#25110;&#23454;&#25968;&#37117;&#21487;&#20197;&#34920;&#31034;&#20026;&#25972;&#25968;&#32034;&#24341;&#21015;&#34920;&#65292;&#34920;&#31034;&#20108;&#36827;&#21046;&#20013;&#30340;&#26377;&#38480;&#32423;&#25968;&#12290;&#35813;&#25968;&#23383;&#30340;&#25972;&#25968;&#32034;&#24341;&#26377;&#38480;&#32423;&#25968;&#21487;&#20197;&#23384;&#20648;&#21644;&#20998;&#24067;&#22312;&#22810;&#20010;CPU / GPU&#19978;&#12290;&#25105;&#20204;&#23637;&#31034;&#20102;&#21152;&#27861;&#21644;&#20056;&#27861;&#36816;&#31639;&#21487;&#20197;&#24212;&#29992;&#20110;&#20316;&#20026;&#32034;&#24341;&#25972;&#25968;&#34920;&#31034;&#30340;&#20004;&#20010;&#34917;&#30721;&#21152;&#27861;&#65292;&#24182;&#21487;&#20197;&#23436;&#20840;&#20998;&#24067;&#22312;&#32473;&#23450;&#30340;CPU / GPU&#26550;&#26500;&#19978;&#12290;&#25105;&#20204;&#23637;&#31034;&#20102;&#23436;&#20840;&#30340;&#20998;&#24067;&#24615;&#33021;&#12290;
&lt;/p&gt;
&lt;p&gt;
We demonstrate a multiplication method based on numbers represented as set of polynomial radix 2 indices stored as an integer list. The 'polynomial integer index multiplication' method is a set of algorithms implemented in python code. We demonstrate the method to be faster than both the Number Theoretic Transform (NTT) and Karatsuba for multiplication within a certain bit range. Also implemented in python code for comparison purposes with the polynomial radix 2 integer method. We demonstrate that it is possible to express any integer or real number as a list of integer indices, representing a finite series in base two. The finite series of integer index representation of a number can then be stored and distributed across multiple CPUs / GPUs. We show that operations of addition and multiplication can be applied as two's complement additions operating on the index integer representations and can be fully distributed across a given CPU / GPU architecture. We demonstrate fully distribute
&lt;/p&gt;</description></item><item><title>&#35813;&#35770;&#25991;&#25552;&#20986;&#20102;&#19968;&#31181;&#24378;&#20581;&#30340;&#20840;&#24322;&#27493;&#26041;&#27861;&#65288;R-FAST&#65289;&#65292;&#22312;&#20998;&#24067;&#24335;&#26426;&#22120;&#23398;&#20064;&#20013;&#35299;&#20915;&#20102;&#23436;&#32654;&#21516;&#27493;&#30340;&#20302;&#25928;&#24615;&#21644;&#19981;&#21487;&#33021;&#24615;&#38382;&#39064;&#65292;&#36890;&#36807;&#37319;&#29992;&#40065;&#26834;&#30340;&#26799;&#24230;&#36319;&#36394;&#31574;&#30053;&#21644;&#28789;&#27963;&#30340;&#36890;&#20449;&#26550;&#26500;&#65292;&#28040;&#38500;&#20102;&#25968;&#25454;&#24322;&#26500;&#24615;&#21644;&#25968;&#25454;&#21253;&#20002;&#22833;&#30340;&#24433;&#21709;&#65292;&#24182;&#23454;&#29616;&#20102;&#26399;&#26395;&#30340;&#37051;&#22495;&#25910;&#25947;&#12290;</title><link>http://arxiv.org/abs/2307.11617</link><description>&lt;p&gt;
&#24378;&#20581;&#30340;&#20840;&#24322;&#27493;&#26041;&#27861;&#29992;&#20110;&#36890;&#29992;&#26550;&#26500;&#19978;&#30340;&#20998;&#24067;&#24335;&#35757;&#32451;
&lt;/p&gt;
&lt;p&gt;
Robust Fully-Asynchronous Methods for Distributed Training over General Architecture. (arXiv:2307.11617v1 [cs.DC])
&lt;/p&gt;
&lt;p&gt;
http://arxiv.org/abs/2307.11617
&lt;/p&gt;
&lt;p&gt;
&#35813;&#35770;&#25991;&#25552;&#20986;&#20102;&#19968;&#31181;&#24378;&#20581;&#30340;&#20840;&#24322;&#27493;&#26041;&#27861;&#65288;R-FAST&#65289;&#65292;&#22312;&#20998;&#24067;&#24335;&#26426;&#22120;&#23398;&#20064;&#20013;&#35299;&#20915;&#20102;&#23436;&#32654;&#21516;&#27493;&#30340;&#20302;&#25928;&#24615;&#21644;&#19981;&#21487;&#33021;&#24615;&#38382;&#39064;&#65292;&#36890;&#36807;&#37319;&#29992;&#40065;&#26834;&#30340;&#26799;&#24230;&#36319;&#36394;&#31574;&#30053;&#21644;&#28789;&#27963;&#30340;&#36890;&#20449;&#26550;&#26500;&#65292;&#28040;&#38500;&#20102;&#25968;&#25454;&#24322;&#26500;&#24615;&#21644;&#25968;&#25454;&#21253;&#20002;&#22833;&#30340;&#24433;&#21709;&#65292;&#24182;&#23454;&#29616;&#20102;&#26399;&#26395;&#30340;&#37051;&#22495;&#25910;&#25947;&#12290;
&lt;/p&gt;
&lt;p&gt;

&lt;/p&gt;
&lt;p&gt;
&#20998;&#24067;&#24335;&#26426;&#22120;&#23398;&#20064;&#38382;&#39064;&#20013;&#23436;&#32654;&#30340;&#21516;&#27493;&#26159;&#20302;&#25928;&#29978;&#33267;&#19981;&#21487;&#33021;&#30340;&#65292;&#30001;&#20110;&#24310;&#36831;&#12289;&#25968;&#25454;&#20002;&#22833;&#21644;&#24310;&#36831;&#36739;&#22823;&#30340;&#35774;&#22791;&#12290;&#25105;&#20204;&#25552;&#20986;&#20102;&#19968;&#31181;&#24378;&#20581;&#30340;&#20840;&#24322;&#27493;&#38543;&#26426;&#26799;&#24230;&#36319;&#36394;&#26041;&#27861;&#65288;R-FAST&#65289;&#65292;&#20854;&#20013;&#27599;&#20010;&#35774;&#22791;&#20197;&#33258;&#24049;&#30340;&#36895;&#24230;&#36827;&#34892;&#26412;&#22320;&#35745;&#31639;&#21644;&#36890;&#20449;&#65292;&#32780;&#26080;&#38656;&#20219;&#20309;&#24418;&#24335;&#30340;&#21516;&#27493;&#12290;&#19982;&#29616;&#26377;&#30340;&#24322;&#27493;&#20998;&#24067;&#24335;&#31639;&#27861;&#19981;&#21516;&#65292;R-FAST&#21487;&#20197;&#36890;&#36807;&#37319;&#29992;&#22522;&#20110;&#35774;&#35745;&#33391;&#22909;&#30340;&#36741;&#21161;&#21464;&#37327;&#26469;&#36319;&#36394;&#21644;&#32531;&#20914;&#25972;&#20307;&#26799;&#24230;&#21521;&#37327;&#30340;&#40065;&#26834;&#26799;&#24230;&#36319;&#36394;&#31574;&#30053;&#65292;&#28040;&#38500;&#35774;&#22791;&#38388;&#25968;&#25454;&#24322;&#26500;&#24615;&#30340;&#24433;&#21709;&#65292;&#24182;&#20801;&#35768;&#25968;&#25454;&#21253;&#20002;&#22833;&#12290;&#26356;&#37325;&#35201;&#30340;&#26159;&#65292;&#25152;&#25552;&#20986;&#30340;&#26041;&#27861;&#21033;&#29992;&#20004;&#20010;&#29983;&#25104;&#26641;&#22270;&#36827;&#34892;&#36890;&#20449;&#65292;&#21482;&#35201;&#20004;&#32773;&#20849;&#20139;&#33267;&#23569;&#19968;&#20010;&#20849;&#21516;&#30340;&#26681;&#33410;&#28857;&#65292;&#23601;&#33021;&#23454;&#29616;&#28789;&#27963;&#30340;&#36890;&#20449;&#26550;&#26500;&#35774;&#35745;&#12290;&#25105;&#20204;&#35777;&#26126;&#20102;R-FAST&#23545;&#20110;&#24179;&#28369;&#21644;&#24378;&#20984;&#38382;&#39064;&#65292;&#25910;&#25947;&#21040;&#26368;&#20248;&#35299;&#30340;&#26399;&#26395;&#37051;&#22495;&#65292;&#24182;&#20855;&#26377;&#20960;&#20309;&#25910;&#25947;&#29575;&#12290;
&lt;/p&gt;
&lt;p&gt;
Perfect synchronization in distributed machine learning problems is inefficient and even impossible due to the existence of latency, package losses and stragglers. We propose a Robust Fully-Asynchronous Stochastic Gradient Tracking method (R-FAST), where each device performs local computation and communication at its own pace without any form of synchronization. Different from existing asynchronous distributed algorithms, R-FAST can eliminate the impact of data heterogeneity across devices and allow for packet losses by employing a robust gradient tracking strategy that relies on properly designed auxiliary variables for tracking and buffering the overall gradient vector. More importantly, the proposed method utilizes two spanning-tree graphs for communication so long as both share at least one common root, enabling flexible designs in communication architectures. We show that R-FAST converges in expectation to a neighborhood of the optimum with a geometric rate for smooth and strongly
&lt;/p&gt;</description></item></channel></rss>