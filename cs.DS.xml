<rss version="2.0"><channel><title>Chat Arxiv cs.DS</title><link>https://github.com/qhduan/cn-chat-arxiv</link><description>This is arxiv RSS feed for cs.DS</description><item><title>&#26412;&#30740;&#31350;&#36890;&#36807;&#21015;&#20030;&#38382;&#39064;&#23454;&#20363;&#24635;&#25439;&#22833;&#20989;&#25968;&#30340;&#37096;&#20998;&#26469;&#25552;&#20986;&#20102;&#22522;&#20110;&#36755;&#20986;&#24863;&#30693;ERM&#30340;&#25968;&#25454;&#39537;&#21160;&#31639;&#27861;&#35774;&#35745;&#25216;&#26415;&#65292;&#35299;&#20915;&#20102;&#22810;&#21442;&#25968;&#32452;&#21512;&#31639;&#27861;&#26063;&#30340;&#35745;&#31639;&#25928;&#29575;&#38382;&#39064;&#12290;</title><link>http://arxiv.org/abs/2204.03569</link><description>&lt;p&gt;
&#22522;&#20110;&#36755;&#20986;&#24863;&#30693;ERM&#30340;&#25968;&#25454;&#39537;&#21160;&#31639;&#27861;&#35774;&#35745;&#25216;&#26415;
&lt;/p&gt;
&lt;p&gt;
Output-sensitive ERM-based techniques for data-driven algorithm design. (arXiv:2204.03569v2 [cs.DS] UPDATED)
&lt;/p&gt;
&lt;p&gt;
http://arxiv.org/abs/2204.03569
&lt;/p&gt;
&lt;p&gt;
&#26412;&#30740;&#31350;&#36890;&#36807;&#21015;&#20030;&#38382;&#39064;&#23454;&#20363;&#24635;&#25439;&#22833;&#20989;&#25968;&#30340;&#37096;&#20998;&#26469;&#25552;&#20986;&#20102;&#22522;&#20110;&#36755;&#20986;&#24863;&#30693;ERM&#30340;&#25968;&#25454;&#39537;&#21160;&#31639;&#27861;&#35774;&#35745;&#25216;&#26415;&#65292;&#35299;&#20915;&#20102;&#22810;&#21442;&#25968;&#32452;&#21512;&#31639;&#27861;&#26063;&#30340;&#35745;&#31639;&#25928;&#29575;&#38382;&#39064;&#12290;
&lt;/p&gt;
&lt;p&gt;

&lt;/p&gt;
&lt;p&gt;
&#25968;&#25454;&#39537;&#21160;&#31639;&#27861;&#35774;&#35745;&#26159;&#19968;&#31181;&#26377;&#28508;&#21147;&#30340;&#22522;&#20110;&#23398;&#20064;&#30340;&#26041;&#27861;&#65292;&#29992;&#20110;&#36229;&#20986;&#26368;&#22351;&#24773;&#20917;&#20998;&#26512;&#20855;&#26377;&#21487;&#35843;&#21442;&#25968;&#30340;&#31639;&#27861;&#12290;&#19968;&#20010;&#37325;&#35201;&#30340;&#24320;&#25918;&#38382;&#39064;&#26159;&#20026;&#20855;&#26377;&#22810;&#20010;&#21442;&#25968;&#30340;&#32452;&#21512;&#31639;&#27861;&#26063;&#35774;&#35745;&#35745;&#31639;&#25928;&#29575;&#39640;&#30340;&#25968;&#25454;&#39537;&#21160;&#31639;&#27861;&#12290;&#24403;&#22266;&#23450;&#38382;&#39064;&#23454;&#20363;&#24182;&#21464;&#21270;&#21442;&#25968;&#26102;&#65292;"&#23545;&#20598;"&#25439;&#22833;&#20989;&#25968;&#36890;&#24120;&#20855;&#26377;&#20998;&#27573;&#21487;&#20998;&#35299;&#30340;&#32467;&#26500;&#65292;&#21363;&#38500;&#20102;&#26576;&#20123;&#23574;&#38160;&#30340;&#36716;&#25442;&#36793;&#30028;&#22806;&#37117;&#34920;&#29616;&#33391;&#22909;&#12290;&#22312;&#26412;&#24037;&#20316;&#20013;&#65292;&#25105;&#20204;&#36890;&#36807;&#21015;&#20030;&#19968;&#32452;&#38382;&#39064;&#23454;&#20363;&#30340;&#24635;&#25439;&#22833;&#20989;&#25968;&#30340;&#37096;&#20998;&#26469;&#24320;&#23637;&#25216;&#26415;&#30740;&#31350;&#65292;&#20197;&#24320;&#21457;&#29992;&#20110;&#25968;&#25454;&#39537;&#21160;&#31639;&#27861;&#35774;&#35745;&#30340;&#39640;&#25928;ERM&#23398;&#20064;&#31639;&#27861;&#12290;&#25105;&#20204;&#30340;&#26041;&#27861;&#30340;&#36816;&#34892;&#26102;&#38388;&#19982;&#23454;&#38469;&#20986;&#29616;&#30340;&#37096;&#20998;&#25968;&#30446;&#25104;&#27604;&#20363;&#65292;&#32780;&#19981;&#26159;&#22522;&#20110;&#37096;&#20998;&#25968;&#30446;&#30340;&#26368;&#22351;&#24773;&#20917;&#19978;&#30028;&#12290;&#25105;&#20204;&#30340;&#26041;&#27861;&#28041;&#21450;&#20004;&#20010;&#26032;&#39062;&#30340;&#35201;&#32032; - &#19968;&#31181;&#29992;&#20110;&#26522;&#20030;&#30001;&#19968;&#32452;&#36229;&#24179;&#38754;&#35825;&#23548;&#30340;&#22810;&#38754;&#20307;&#30340;&#36755;&#20986;&#24863;&#30693;&#31639;&#27861;&#12290;
&lt;/p&gt;
&lt;p&gt;
Data-driven algorithm design is a promising, learning-based approach for beyond worst-case analysis of algorithms with tunable parameters. An important open problem is the design of computationally efficient data-driven algorithms for combinatorial algorithm families with multiple parameters. As one fixes the problem instance and varies the parameters, the "dual" loss function typically has a piecewise-decomposable structure, i.e. is well-behaved except at certain sharp transition boundaries. In this work we initiate the study of techniques to develop efficient ERM learning algorithms for data-driven algorithm design by enumerating the pieces of the sum dual loss functions for a collection of problem instances. The running time of our approach scales with the actual number of pieces that appear as opposed to worst case upper bounds on the number of pieces. Our approach involves two novel ingredients -- an output-sensitive algorithm for enumerating polytopes induced by a set of hyperpla
&lt;/p&gt;</description></item></channel></rss>