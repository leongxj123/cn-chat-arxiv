<rss version="2.0"><channel><title>Chat Arxiv cs.DS</title><link>https://github.com/qhduan/cn-chat-arxiv</link><description>This is arxiv RSS feed for cs.DS</description><item><title>&#35770;&#25991;&#30740;&#31350;&#20102;&#22312;&#39044;&#27979;&#31639;&#27861;&#33539;&#24335;&#19979;&#35774;&#35745;&#25903;&#25345;&#39030;&#28857;&#22833;&#36133;&#30340;&#36830;&#36890;&#24615;&#39044;&#27979;&#22120;&#30340;&#38382;&#39064;&#65292;&#24182;&#25552;&#20986;&#20102;&#19968;&#31181;&#25968;&#25454;&#32467;&#26500;&#65292;&#33021;&#22815;&#20197;&#39044;&#22788;&#29702;&#26102;&#38388;&#21644;&#26597;&#35810;&#26102;&#38388;&#30340;&#22810;&#39033;&#24335;&#20851;&#31995;&#26469;&#22788;&#29702;&#22833;&#36133;&#39030;&#28857;&#38598;&#21512;&#12290;</title><link>https://arxiv.org/abs/2312.08489</link><description>&lt;p&gt;
&#39044;&#27979;&#39030;&#28857;&#22833;&#36133;&#30340;&#36830;&#36890;&#24615;&#39044;&#27979;&#22120;
&lt;/p&gt;
&lt;p&gt;
Connectivity Oracles for Predictable Vertex Failures
&lt;/p&gt;
&lt;p&gt;
https://arxiv.org/abs/2312.08489
&lt;/p&gt;
&lt;p&gt;
&#35770;&#25991;&#30740;&#31350;&#20102;&#22312;&#39044;&#27979;&#31639;&#27861;&#33539;&#24335;&#19979;&#35774;&#35745;&#25903;&#25345;&#39030;&#28857;&#22833;&#36133;&#30340;&#36830;&#36890;&#24615;&#39044;&#27979;&#22120;&#30340;&#38382;&#39064;&#65292;&#24182;&#25552;&#20986;&#20102;&#19968;&#31181;&#25968;&#25454;&#32467;&#26500;&#65292;&#33021;&#22815;&#20197;&#39044;&#22788;&#29702;&#26102;&#38388;&#21644;&#26597;&#35810;&#26102;&#38388;&#30340;&#22810;&#39033;&#24335;&#20851;&#31995;&#26469;&#22788;&#29702;&#22833;&#36133;&#39030;&#28857;&#38598;&#21512;&#12290;
&lt;/p&gt;
&lt;p&gt;

&lt;/p&gt;
&lt;p&gt;
&#35774;&#35745;&#25903;&#25345;&#39030;&#28857;&#22833;&#36133;&#30340;&#36830;&#36890;&#24615;&#39044;&#27979;&#22120;&#26159;&#38024;&#23545;&#26080;&#21521;&#22270;&#30340;&#22522;&#26412;&#25968;&#25454;&#32467;&#26500;&#38382;&#39064;&#20043;&#19968;&#12290;&#24050;&#26377;&#30340;&#30740;&#31350;&#22312;&#26597;&#35810;&#26102;&#38388;&#26041;&#38754;&#24050;&#32463;&#26377;&#20102;&#24456;&#22909;&#30340;&#29702;&#35299;&#65306;&#20197;&#21069;&#30340;&#20316;&#21697;[Duan-Pettie STOC'10; Long-Saranurak FOCS'22]&#23454;&#29616;&#20102;&#19982;&#22833;&#36133;&#39030;&#28857;&#25968;&#37327;&#25104;&#32447;&#24615;&#20851;&#31995;&#30340;&#26597;&#35810;&#26102;&#38388;&#65292;&#24182;&#19988;&#22312;&#38656;&#35201;&#22810;&#39033;&#24335;&#26102;&#38388;&#30340;&#39044;&#22788;&#29702;&#21644;&#22810;&#39033;&#24335;&#26102;&#38388;&#30340;&#26356;&#26032;&#30340;&#26465;&#20214;&#19979;&#26159;&#26377;&#26465;&#20214;&#26368;&#20248;&#30340;&#12290;&#25105;&#20204;&#22312;&#39044;&#27979;&#31639;&#27861;&#30340;&#33539;&#24335;&#19979;&#37325;&#26032;&#23457;&#35270;&#20102;&#36825;&#20010;&#38382;&#39064;&#65306;&#25105;&#20204;&#38382;&#65292;&#22914;&#26524;&#21487;&#20197;&#39044;&#27979;&#21040;&#22833;&#36133;&#39030;&#28857;&#38598;&#21512;&#65292;&#26597;&#35810;&#26102;&#38388;&#26159;&#21542;&#21487;&#20197;&#25552;&#39640;&#12290;&#26356;&#20855;&#20307;&#22320;&#35828;&#65292;&#25105;&#20204;&#35774;&#35745;&#20102;&#19968;&#20010;&#25968;&#25454;&#32467;&#26500;&#65292;&#32473;&#23450;&#19968;&#20010;&#22270;G=(V,E)&#21644;&#19968;&#20010;&#39044;&#27979;&#20250;&#22833;&#36133;&#30340;&#39030;&#28857;&#38598;&#21512;\widehat{D} \subseteq V&#65288;&#20854;&#20013;d=|\widehat{D}|&#65289;&#65292;&#23558;&#20854;&#39044;&#22788;&#29702;&#26102;&#38388;&#20026;$\tilde{O}(d|E|)$&#65292;&#28982;&#21518;&#21487;&#20197;&#25509;&#25910;&#19968;&#20010;&#26356;&#26032;&#65292;&#35813;&#26356;&#26032;&#20197;&#23545;&#31216;&#24046;&#20998;&#24418;&#24335;&#32473;&#20986;&#12290;
&lt;/p&gt;
&lt;p&gt;
arXiv:2312.08489v2 Announce Type: replace-cross  Abstract: The problem of designing connectivity oracles supporting vertex failures is one of the basic data structures problems for undirected graphs. It is already well understood: previous works [Duan--Pettie STOC'10; Long--Saranurak FOCS'22] achieve query time linear in the number of failed vertices, and it is conditionally optimal as long as we require preprocessing time polynomial in the size of the graph and update time polynomial in the number of failed vertices.   We revisit this problem in the paradigm of algorithms with predictions: we ask if the query time can be improved if the set of failed vertices can be predicted beforehand up to a small number of errors. More specifically, we design a data structure that, given a graph $G=(V,E)$ and a set of vertices predicted to fail $\widehat{D} \subseteq V$ of size $d=|\widehat{D}|$, preprocesses it in time $\tilde{O}(d|E|)$ and then can receive an update given as the symmetric differ
&lt;/p&gt;</description></item><item><title>&#26412;&#25991;&#25552;&#20986;&#20102;&#19968;&#20010;SGD-like&#31639;&#27861;&#65292;&#27880;&#20837;&#38543;&#26426;&#22122;&#22768;&#24182;&#21033;&#29992;&#20998;&#24067;&#23545;&#31216;&#24615;&#26469;&#20943;&#23569;&#26041;&#24046;&#65292;&#20197;&#23547;&#25214;&#20855;&#26377;&#20302;&#28023;&#26862;&#30697;&#38453;&#36857;&#30340;&#24179;&#22374;&#26497;&#23567;&#20540;&#65292;&#21516;&#26102;&#25552;&#20379;&#20102;&#25910;&#25947;&#36895;&#29575;&#20998;&#26512;&#12290;</title><link>http://arxiv.org/abs/2306.08553</link><description>&lt;p&gt;
&#22122;&#22768;&#31283;&#23450;&#20248;&#21270;&#23545;&#20110;&#20855;&#26377;&#26368;&#20248;&#25910;&#25947;&#29575;&#30340;&#24179;&#22374;&#26497;&#23567;&#20540;&#30340;&#24433;&#21709;
&lt;/p&gt;
&lt;p&gt;
Noise Stability Optimization for Flat Minima with Optimal Convergence Rates. (arXiv:2306.08553v1 [cs.LG])
&lt;/p&gt;
&lt;p&gt;
http://arxiv.org/abs/2306.08553
&lt;/p&gt;
&lt;p&gt;
&#26412;&#25991;&#25552;&#20986;&#20102;&#19968;&#20010;SGD-like&#31639;&#27861;&#65292;&#27880;&#20837;&#38543;&#26426;&#22122;&#22768;&#24182;&#21033;&#29992;&#20998;&#24067;&#23545;&#31216;&#24615;&#26469;&#20943;&#23569;&#26041;&#24046;&#65292;&#20197;&#23547;&#25214;&#20855;&#26377;&#20302;&#28023;&#26862;&#30697;&#38453;&#36857;&#30340;&#24179;&#22374;&#26497;&#23567;&#20540;&#65292;&#21516;&#26102;&#25552;&#20379;&#20102;&#25910;&#25947;&#36895;&#29575;&#20998;&#26512;&#12290;
&lt;/p&gt;
&lt;p&gt;

&lt;/p&gt;
&lt;p&gt;
&#26412;&#25991;&#30740;&#31350;&#36890;&#36807;&#21152;&#20837;&#21152;&#26435;&#25200;&#21160;&#26469;&#25214;&#21040;&#24179;&#22374;&#30340;&#26497;&#23567;&#20540;&#12290;&#32473;&#23450;&#19968;&#20010;&#38750;&#20984;&#20989;&#25968;$f:\mathbb{R}^d\rightarrow \mathbb{R}$&#21644;&#19968;&#20010;$d$&#32500;&#20998;&#24067;$\mathcal{P}$&#65292;&#25105;&#20204;&#25200;&#21160;$f$&#30340;&#26435;&#37325;&#65292;&#24182;&#23450;&#20041;$F(W)=\mathbb{E}[f({W+U})]$&#65292;&#20854;&#20013;$U$&#26159;&#19968;&#20010;&#20174;$\mathcal{P}$&#20013;&#38543;&#26426;&#25277;&#21462;&#30340;&#26679;&#26412;&#12290;&#36825;&#20010;&#36807;&#31243;&#36890;&#36807;$f$&#30340;&#28023;&#26862;&#30697;&#38453;&#30340;&#36857;&#26469;&#35825;&#23548;&#27491;&#21017;&#21270;&#65292;&#20197;&#36866;&#24212;&#20110;&#23567;&#30340;&#12289;&#21508;&#21521;&#21516;&#24615;&#30340;&#39640;&#26031;&#25200;&#21160;&#12290;&#22240;&#27492;&#65292;&#21152;&#26435;&#25200;&#21160;&#30340;&#20989;&#25968;&#20559;&#21521;&#20110;&#24102;&#26377;&#20302;&#28023;&#26862;&#30697;&#38453;&#36857;&#30340;&#26497;&#23567;&#20540;&#12290;&#26412;&#25991;&#25552;&#20986;&#20102;&#19968;&#31181;&#31867;&#20284;&#20110;SGD&#30340;&#31639;&#27861;&#65292;&#22312;&#35745;&#31639;&#26799;&#24230;&#20043;&#21069;&#27880;&#20837;&#38543;&#26426;&#22122;&#22768;&#65292;&#21516;&#26102;&#21033;&#29992;$\mathcal{P}$&#30340;&#23545;&#31216;&#24615;&#26469;&#20943;&#23569;&#26041;&#24046;&#12290;&#25105;&#20204;&#36824;&#25552;&#20379;&#20102;&#20005;&#26684;&#30340;&#20998;&#26512;&#65292;&#35777;&#26126;&#20102;...
&lt;/p&gt;
&lt;p&gt;
We consider finding flat, local minimizers by adding average weight perturbations. Given a nonconvex function $f: \mathbb{R}^d \rightarrow \mathbb{R}$ and a $d$-dimensional distribution $\mathcal{P}$ which is symmetric at zero, we perturb the weight of $f$ and define $F(W) = \mathbb{E}[f({W + U})]$, where $U$ is a random sample from $\mathcal{P}$. This injection induces regularization through the Hessian trace of $f$ for small, isotropic Gaussian perturbations. Thus, the weight-perturbed function biases to minimizers with low Hessian trace. Several prior works have studied settings related to this weight-perturbed function by designing algorithms to improve generalization. Still, convergence rates are not known for finding minima under the average perturbations of the function $F$. This paper considers an SGD-like algorithm that injects random noise before computing gradients while leveraging the symmetry of $\mathcal{P}$ to reduce variance. We then provide a rigorous analysis, showing
&lt;/p&gt;</description></item></channel></rss>